"""Add pgqueuer tables for task scheduling

Revision ID: f9g0h1i2j3k4
Revises: f8g9h0i1j2k3
Create Date: 2026-02-15 16:45:00.000000

"""

from collections.abc import Sequence

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "f9g0h1i2j3k4"
down_revision: str | None = "f8g9h0i1j2k3"
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    # Create pgqueuer status enum type (if not already exists)
    # We use a DO block to handle the case where the type already exists
    op.execute(
        """
        DO $$
        BEGIN
            CREATE TYPE pgqueuer_status AS ENUM ('queued', 'picked',
                'successful', 'exception', 'canceled', 'deleted');
        EXCEPTION WHEN duplicate_object THEN
            null;
        END $$;
        """
    )

    # Create main pgqueuer queue table
    op.execute(
        """
        CREATE TABLE IF NOT EXISTS pgqueuer (
            id SERIAL PRIMARY KEY,
            priority INT NOT NULL,
            queue_manager_id UUID,
            created TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            updated TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            heartbeat TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            execute_after TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            status pgqueuer_status NOT NULL,
            entrypoint TEXT NOT NULL,
            dedupe_key TEXT,
            payload BYTEA,
            headers JSONB
        )
        """
    )

    # Create indexes on pgqueuer table
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_priority_id_id1_idx ON pgqueuer
            (priority ASC, id DESC) INCLUDE (id) WHERE status = 'queued'
        """
    )
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_updated_id_id1_idx ON pgqueuer
            (updated ASC, id DESC) INCLUDE (id) WHERE status = 'picked'
        """
    )
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_queue_manager_id_idx ON pgqueuer
            (queue_manager_id) WHERE queue_manager_id IS NOT NULL
        """
    )
    op.execute(
        """
        CREATE UNIQUE INDEX IF NOT EXISTS pgqueuer_unique_dedupe_key ON pgqueuer
            (dedupe_key) WHERE ((status IN ('queued', 'picked') AND dedupe_key IS NOT NULL))
        """
    )

    # Create pgqueuer_log table
    op.execute(
        """
        CREATE TABLE IF NOT EXISTS pgqueuer_log (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            created TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            job_id BIGINT NOT NULL,
            status pgqueuer_status NOT NULL,
            priority INT NOT NULL,
            entrypoint TEXT NOT NULL,
            traceback JSONB DEFAULT NULL,
            aggregated BOOLEAN DEFAULT FALSE
        )
        """
    )

    # Create indexes on pgqueuer_log table
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_log_not_aggregated ON pgqueuer_log
            ((1)) WHERE not aggregated
        """
    )
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_log_created ON pgqueuer_log (created)
        """
    )
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_log_status ON pgqueuer_log (status)
        """
    )
    op.execute(
        """
        CREATE INDEX IF NOT EXISTS pgqueuer_log_job_id_status ON pgqueuer_log
            (job_id, created DESC)
        """
    )

    # Create pgqueuer_statistics table
    op.execute(
        """
        CREATE TABLE IF NOT EXISTS pgqueuer_statistics (
            id SERIAL PRIMARY KEY,
            created TIMESTAMP WITH TIME ZONE NOT NULL
                DEFAULT DATE_TRUNC('sec', NOW() at time zone 'UTC'),
            count BIGINT NOT NULL,
            priority INT NOT NULL,
            status pgqueuer_status NOT NULL,
            entrypoint TEXT NOT NULL
        )
        """
    )

    # Create unique index on pgqueuer_statistics
    op.execute(
        """
        CREATE UNIQUE INDEX IF NOT EXISTS pgqueuer_statistics_unique_count ON
            pgqueuer_statistics (
                priority,
                DATE_TRUNC('sec', created at time zone 'UTC'),
                status,
                entrypoint
            )
        """
    )

    # Create pgqueuer_schedules table
    op.execute(
        """
        CREATE TABLE IF NOT EXISTS pgqueuer_schedules (
            id SERIAL PRIMARY KEY,
            expression TEXT NOT NULL,
            entrypoint TEXT NOT NULL,
            heartbeat TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            created TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            updated TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            next_run TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
            last_run TIMESTAMP WITH TIME ZONE,
            status pgqueuer_status DEFAULT 'queued',
            UNIQUE (expression, entrypoint)
        )
        """
    )

    # Create the notification trigger function
    op.execute(
        """
        CREATE OR REPLACE FUNCTION fn_pgqueuer_changed() RETURNS TRIGGER AS $$
        DECLARE
            to_emit BOOLEAN := false;  -- Flag to decide whether to emit a notification
        BEGIN
            -- Check operation type and set the emit flag accordingly
            IF TG_OP = 'UPDATE' AND OLD IS DISTINCT FROM NEW THEN
                to_emit := true;
            ELSIF TG_OP = 'DELETE' THEN
                to_emit := true;
            ELSIF TG_OP = 'INSERT' THEN
                to_emit := true;
            ELSIF TG_OP = 'TRUNCATE' THEN
                to_emit := true;
            END IF;

            -- Perform notification if the emit flag is set
            IF to_emit THEN
                PERFORM pg_notify(
                    'ch_pgqueuer',
                    json_build_object(
                        'channel', 'ch_pgqueuer',
                        'operation', lower(TG_OP),
                        'sent_at', NOW(),
                        'table', TG_TABLE_NAME,
                        'type', 'table_changed_event'
                    )::text
                );
            END IF;

            -- Return appropriate value based on the operation
            IF TG_OP IN ('INSERT', 'UPDATE') THEN
                RETURN NEW;
            ELSIF TG_OP = 'DELETE' THEN
                RETURN OLD;
            ELSE
                RETURN NULL; -- For TRUNCATE and other non-row-specific contexts
            END IF;

        END;
        $$ LANGUAGE plpgsql;
        """
    )

    # Create the trigger on pgqueuer table (if not already exists)
    op.execute(
        """
        DO $$
        BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM information_schema.triggers
                WHERE trigger_name = 'tg_pgqueuer_changed'
            ) THEN
                CREATE TRIGGER tg_pgqueuer_changed
                AFTER INSERT OR UPDATE OR DELETE OR TRUNCATE ON pgqueuer
                EXECUTE FUNCTION fn_pgqueuer_changed();
            END IF;
        END;
        $$;
        """
    )


def downgrade() -> None:
    # Drop trigger and function
    op.execute("DROP TRIGGER IF EXISTS tg_pgqueuer_changed ON pgqueuer")
    op.execute("DROP FUNCTION IF EXISTS fn_pgqueuer_changed()")

    # Drop tables
    op.execute("DROP TABLE IF EXISTS pgqueuer_schedules")
    op.execute("DROP TABLE IF EXISTS pgqueuer_statistics")
    op.execute("DROP TABLE IF EXISTS pgqueuer_log")
    op.execute("DROP TABLE IF EXISTS pgqueuer")

    # Drop enum type
    op.execute("DROP TYPE IF EXISTS pgqueuer_status")
